# Идеи по улучшению качества политики (доля решённых заданий)

## Формулировка проблемы

Типичный сбой на open_fridge: **гриппер закрывается, но не там, где ручка** — с небольшим промахом по позиции или ориентации. Робот «промахнулся» в критический момент (место захвата), но дальше ведёт руку так, как будто дверца захвачена. То есть ошибка — **пространственная (pose в момент закрытия)**, а не «не закрыл» или «закрыл не в тот момент по времени».

Ниже — идеи, сфокусированные на том, чтобы **точнее попадать в место и позу захвата** и не продолжать траекторию «как будто всё ок», если критический момент прозеван.

---

## Разметка момента захвата в демо и как часто меняется gripper

**Можно ли разметить момент захвата по текущим данным?** Да. В демонстрациях уже есть всё нужное:

- В **zarr** (собранные через `collect_demos.py`) и в **записанных JSON** (наши `recordings/open_fridge_seed*.json`) на каждом шаге сохраняется `robot_state` длины 10: `[px, py, pz, rot6d(6), gripper]`. Последняя компонента — это `obs.gripper_open` из RLBench (степень открытости, обычно 0 = закрыт, 1 = открыт; в коде ещё делают сдвиг на 0.5 при нормализации).
- **Момент захвата** можно пометить автоматически: первый шаг `t`, где gripper переходит из «открыт» в «закрыт». Например: `gripper[t-1] > 0.5` и `gripper[t] < 0.5` (порог подобрать под свои значения). Этот шаг и есть ключевой кадр — поза EE в нём и есть «целевая поза захвата» для этого демо.

Ручная разметка не обязательна: достаточно один раз пройти по всем эпизодам в zarr/JSON, вычислить такой шаг для каждой траектории, и сохранить индекс (или маску по шагам) для использования в обучении (keyframe loss, п. 1).

**Как часто гриппер меняет положение?** В задачах вроде open_fridge — **редко**: за эпизод обычно **1–2 перехода**. Типичный сценарий:

- Старт: gripper открыт (рука едет к ручке).
- Один раз **закрытие** — захват ручки (единственный критичный момент).
- Дальше gripper остаётся закрыт на всём движении «тяни дверцу».
- Опционально в конце — **открытие** (отпустить ручку).

То есть переходов мало, и «первое закрытие» однозначно задаёт единственный ключевой кадр захвата. Для других задач (вставить вилку, взять предмет и т.д.) может быть два закрытия (взять — положить), но число переходов всё равно небольшое. Имеет смысл при разметке считать все шаги, где gripper переходит open→closed, и использовать первый такой шаг как grasp keyframe (или все, если нужно размечать несколько захватов).

---

## Как считается loss и почему «выделить момент захвата» не тривиально

**Как устроены данные в обучении:** Датасет не отдаёт целую траекторию эпизода. Сэмплер вырезает из эпизода **случайный кусок** фиксированной длины:
- `robot_state_obs` — первые `n_obs_steps` шагов (например 2) этого куска,
- `robot_state_pred` — следующие `n_pred_steps` шагов (например 32).

То есть каждый батч — это набор таких **случайных окон** из разных эпизодов. Нумерация шагов в `robot_state_pred` — это 0, 1, …, T−1 **внутри окна**, а не абсолютный номер шага в исходном эпизоде. Мы не знаем «это окно вокруг захвата» или «это кусок после захвата», пока не посмотрим на сам сигнал (gripper) внутри окна.

**Как считается loss (FMPolicy):** В `calculate_loss`:
1. Берётся один и тот же **случайный момент времени flow** `t` на весь батч (SNR sampling): это параметр интерполяции в flow matching, не номер шага траектории.
2. Строится интерполяция: `z0` — шум, `z1 = robot_state_pred` (целевая траектория (B, T, 10)), `z_t = t*z1 + (1-t)*z0`, `target_vel = z1 - z0`.
3. Сеть по `z_t` и контексту предсказывает поле скоростей `pred_vel` той же формы (B, T, 10).
4. Loss считается как **среднее по всем элементам**:  
   `loss_xyz = MSE(pred_vel[..., :3], target_vel[..., :3])` — один скаляр по всей размерности (B, T, 3); аналогично rot6d и grip. То есть **все T шагов и все батчи вносят вклад одинаково**.

**Почему не так просто выделить критический момент:**
- В текущем коде нет понятия «этот шаг в окне — момент захвата». Окно вырезается случайно, момент захвата может попасть в любой из T шагов или не попасть вовсе (окно целиком до или после захвата).
- Чтобы дать больший вес шагам «около захвата», нужно:  
  (1) **знать внутри окна**, где захват: например, вычислить по `robot_state_pred` первый шаг с переходом gripper open→closed;  
  (2) **менять способ усреднения loss**: не один общий MSE по (B, T), а взвешенная сумма по шагам (например, `reduction='none'` и маска по шагам с большим весом вокруг этого перехода).

**Что можно сделать практически:**  
- В датасете при выдаче сэмпла по `robot_state_pred` вычислить, есть ли в окне переход gripper (open→closed), и если да — вернуть индекс шага внутри окна (или маску по T).  
- В `calculate_loss` принимать опциональную маску весов по шагам (B, T) или (T,): считать per-step loss с `reduction='none'`, умножать на маску (например, 1 везде и 3–5 в окне ±2 шага вокруг перехода), затем брать сумму/среднее. Тогда «время возле критического момента» будет выделено без переделки архитектуры, но с доработкой датасета и функции потерь.

---

## Теория: разметка критических моментов и взвешенный loss

**Что можно получить в принципе (независимо от текущего кода):**

1. **Заранее разметить критические моменты** (например, первый шаг с переходом gripper open→closed в каждом эпизоде) и **вырезать куски так, чтобы критический момент попадал в нужное место**: например, только те окна, где «шаг захвата» лежит внутри окна, и сохранять для каждого такого сэмпла индекс `k` (шаг внутри окна, где захват). Либо вообще резать окна не случайно, а с выравниванием по ключевому кадру (критический момент всегда, скажем, на шаге 10 из 32). Тогда в каждом батч-элементе мы знаем, какие шаги траектории «критичные».

2. **Модель предсказывает некоторую величину по траектории** — в flow matching это поле скоростей (или сдвиг) в каждой точке траектории: на выходе есть значение для каждого шага `t = 0, …, T−1`. Целевое значение тоже есть на каждом шаге (из демо). Поэтому **ошибку можно считать пошагово**: для каждого шага `t` есть `err_t` (например MSE между предсказанием и целью на этом шаге). Итоговый loss — это всегда какая-то функция от набора `{ err_t }`. Сейчас это просто среднее по `t`. Ничто не мешает заменить его на **взвешенную сумму**:  
   `L = Σ_t w_t · err_t / Σ_t w_t`,  
   где `w_t` — веса (например, 1 везде и 3–5 в окне ±2 шага вокруг критического момента). Модель по-прежнему предсказывает ту же величину (скорость/сдвиг); мы лишь меняем, **где** ошибка сильнее штрафуется.

3. **Итог:** Да, в теории можно и заранее разметить критические моменты, и вырезать куски с ними, и считать loss потяжелее вокруг этих шагов. Предсказание скорости (или любой другой пошаговой величины) с этим совместимо: у нас есть ошибка на каждом шаге, и мы вправе усреднять её с любыми весами по времени. Конкретная схема обучения (flow matching, diffusion, авторегрессия и т.д.) меняет только вид `err_t`, но идея взвешивания по шагам остаётся той же.

---

## 1. Усилить точность позы именно в момент захвата (keyframe loss)

**Сейчас:** Loss равномерно по всей траектории (xyz, rot6d, grip с постоянными весами). Ошибка в одном шаге — в момент закрытия gripper — весит так же, как ошибка в любом другом шаге.

**Проблема:** Сеть может хорошо подгонять «подход» и «тягу», но чуть ошибаться в том единственном кадре, где нужно быть строго у ручки. Этого достаточно для провала.

**Идея:**
- В демо автоматически помечать **шаг захвата** (например, первый шаг, где gripper переходит из open в closed).
- Ввести **взвешивание по времени**: в `calculate_loss` умножать loss (xyz и rot6d) на маску, которая **увеличена** на шагах вокруг момента захвата (например, ±2–5 шагов). Так модель сильнее подгоняет **позу именно в момент закрытия**.
- Опционально: отдельный член loss только для «grasp keyframe» — например, L2 между предсказанной позой и целевой позой только в этот один шаг (или окно из 3 шагов).

**Где менять:** `pfp/policy/fm_policy.py` — `calculate_loss` (принимать или вычислять маску по шагам; маска по `robot_state_pred` через Δgripper между соседними шагами). Плюс конфиг: включение keyframe weighting и при необходимости размер окна.

---

## 2. Явная «цель захвата» из облака и loss по ней

**Идея:** Дать модели явный сигнал «где ручка»:
- Из point cloud в зоне манипуляции оценивать **целевую точку/позу захвата** (например, кластер перед EE, или обученная голова «где ручка» по pcd). В демо эту цель можно брать как позу EE в момент первого закрытия gripper.
- Обучать политику не только предсказывать траекторию, но и:
  - **Вариант A:** вспомогательная голова «предсказать pose ручки» (или смещение EE→ручка) по pcd; loss на этой голове + основной траектории.
  - **Вариант B:** в момент ключевого кадра добавлять в loss член «предсказанная поза EE должна совпадать с оцененной позой ручки из pcd» (если такую оценку умеем получать).

**Плюс:** Модель явно учится «совмещать EE с объектом захвата», а не только повторять общую форму траектории.

---

## 3. Инференс: не закрывать, пока EE далеко от «ручки»

**Идея:** Даже если политика выдает «close», исполнять закрытие только когда текущая поза EE **достаточно близка** к оцененной позиции ручки:
- Оценка ручки: например, центр масс точек pcd в передней части холодильника, или ближайший к EE кластер в заданной зоне; можно упростить до «расстояние до плоскости двери + высота ручки».
- Порог: `dist(ee_position, handle_estimate) < d_max` и при необходимости выравнивание ориентации. Параметры задать по демо.
- Если политика говорит «close», но порог не выполнен — на этом шаге **не** менять gripper (или подать «подойти ещё», т.е. оставить только компоненту движения к ручке из предсказания), и на следующем шаге снова проверить. Так мы не даём «закрыть мимо».

**Реализация:** в `rlbench_runner` / обвязке перед вызовом `env.step`: подменять или корректировать действие (gripper оставить open), если условие близости к ручке не выполнено.

---

## 4. Детекция «промаха» и остановка траектории «тяги»

**Проблема:** После того как робот закрыл gripper не по ручке, политика продолжает выдавать траекторию «тянуть дверцу». Исполнять её бессмысленно и может выглядеть как «ведёт руку как с захваченной дверцей».

**Идея:**
- **Критерий провала захвата:** например, gripper закрыт, но через 1–2 шага «тяги» дверца не открылась (нет ожидаемого движения в сцене) или сила/контакт в симуляции ниже порога. Либо проще: после команды «close» проверить, что EE был в момент закрытия в заданной зоне относительно оценки ручки (если нет — считать захват неудачным).
- **Поведение при провале:** не продолжать слепо предсказанную траекторию. Варианты: (a) остановиться и перепланировать (сброс цели «открыть дверцу», новая попытка подхода и захвата), (b) один раз выполнить «корректирующую» подпоследовательность: открыть gripper, короткое движение к оцененной ручке, снова закрыть (см. п. 3).

**Реализация:** в раннере после шага с «close» опционально проверять критерий; при срабатывании — переходить в режим «retry grasp» или останавливать эпизод.

---

## 5. Улучшить представление сцены вокруг ручки

**Сейчас:** Один общий point cloud, ручка — просто часть точек. Небольшое смещение предсказания может «не попасть» в ручку.

**Идеи:**
- **Больше точек в зоне манипуляции:** увеличить `n_points` или семплировать точки с приоритетом в окрестности текущего EE и типичной зоны ручки (по AABB или по демо).
- **Локальная система координат:** аугментации или дополнительный вход «ручка в какой-то локальной сетке относительно EE», чтобы сеть явно училась относительному положению «EE ↔ ручка».
- **Attention / ключевые точки:** обученная или эвристическая разметка «точки ручки» в pcd и усиление их использования в backbone (например, дополнительный loss или отдельный токен «handle»).

---

## 6. Фаза «подход к ручке» с большей точностью

**Идея:** Выделить фазу «последние шаги перед закрытием» и обрабатывать её точнее:
- **Обучение:** в окне за 5–10 шагов до момента закрытия gripper увеличить вес loss по xyz/rot6d (как в п. 1), чтобы траектория подхода к ручке была точнее.
- **Инференс:** в этом окне можно замедлить шаги (чаще перевызывать политику при том же «логическом» движении) или использовать только ту часть предсказания, которая соответствует «подходу», и проверять близость к ручке перед разрешением «close» (п. 3).

---

## 7. Аугментации, сохраняющие относительную позу EE–ручка

**Идея:** При аугментациях сцены (сдвиг/поворот pcd и траектории) убедиться, что **относительное положение EE и ручки** в момент захвата не искажается сверх разумного:
- Например, аугментировать «глобально», но в ключевом кадре добавлять небольшой штраф, если после аугментации смещение «EE − ручка» в демо стало больше порога. Или аугментировать только «до» и «после» фазы захвата, а окно захвата оставлять с меньшим разбросом.
- Так модель видит разные общие сцены, но критичная поза «у ручки» остаётся хорошо выровненной.

---

## 8. Отдельная голова «поза для захвата» (grasp pose)

**Идея:** Оставить основную сеть для полной траектории, но добавить выход (или маленькую голову), который предсказывает **целевую позу EE для захвата** (одну точку в пространстве действий: xyz + ориентация в момент close):
- Обучать по ключевому кадру из демо (поза в момент закрытия gripper).
- На инференсе: когда политика решает «сейчас закрыть», можно (a) подставить или смешать эту позу с предсказанием основной сети (коррекция к «цели захвата»), или (b) разрешать «close» только когда текущая EE близка к этой предсказанной «grasp pose» (аналог п. 3, но цель берётся из сети).

**Плюс:** Явное выделение «куда именно нужно попасть, чтобы схватить» и возможность не продолжать «тягу», если в эту позу не попали.

---

## Приоритизация

1. **Быстро, без смены архитектуры:** п. 1 (взвешивание loss по ключевому кадру захвата), п. 3 (не закрывать, пока EE далеко от оценки ручки).
2. **Средняя сложность:** п. 4 (детекция промаха и остановка/retry вместо слепой «тяги»), п. 6 (усиление точности в фазе подхода).
3. **Глубже:** п. 2 (явная цель захвата из pcd и loss по ней), п. 8 (голова «grasp pose»).

Если нужно, можно оформить следующий шаг как конкретный патч (например, только п. 1 в `fm_policy` + конфиг и эвристика п. 3 в раннере).
